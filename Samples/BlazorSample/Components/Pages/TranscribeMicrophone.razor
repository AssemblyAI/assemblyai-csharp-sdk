@page "/transcribe-microphone"
@implements IAsyncDisposable
@rendermode InteractiveServer
@using System.Diagnostics
@using System.Net.WebSockets
@using System.Text
@using AssemblyAI
@using AssemblyAI.Realtime
@using ReactiveUI

<PageTitle>Transcribe Microphone</PageTitle>

<div class="mb-3">
    <label class="form-label" for="transcribe-toggle-button">Transcribe audio from your microphone:</label> <br>
    <button
        class="btn btn-primary"
        id="transcribe-toggle-button"
        @onclick="TranscribeToggleClick"
        type="button"
        enabled="@(Status is RealtimeTranscriberStatus.Connected or RealtimeTranscriberStatus.Disconnected)"
        disabled="@(Status is RealtimeTranscriberStatus.Connecting or RealtimeTranscriberStatus.Disconnecting)">
        @switch (Status)
        {
            case RealtimeTranscriberStatus.Disconnected:
                <text>Start Transcribing</text>
                break;
            case RealtimeTranscriberStatus.Connecting:
                <text>Connecting...</text>
                break;
            case RealtimeTranscriberStatus.Connected:
                <text>Stop Transcribing</text>
                break;
            case RealtimeTranscriberStatus.Disconnecting:
                <text>Disconnecting...</text>
                break;
            default:
                throw new UnreachableException();
        }
    </button>
</div>

<textarea 
    class="form-control flex-fill mb-2"
    readonly="readonly" 
    placeholder="Start transcribing to see your transcript in real-time here."
    rows="20"
    style="width: 100%"
>@Transcript</textarea>

@code {
    [Inject] private AppState AppState { get; set; }
    [Inject] private IConfiguration Configuration { get; set; }
    [Inject] private IJSRuntime JsRuntime { get; set; }
    [Inject] private NavigationManager NavigationManager { get; set; }
    [Inject] private HttpClient HttpClient { get; set; }
    [Inject] private AssemblyAI AssemblyAIClient { get; set; }
    private RealtimeTranscriber? _transcriber;
    private readonly SortedDictionary<int, string> _transcriptWords = new();
    private JsMicrophone? _jsMicrophone;

    public string Transcript { get; set; } = "";

    public RealtimeTranscriberStatus Status { get; set; }

    public string Error { get; set; }

    protected override void OnInitialized()
    {
        AppState.TopRowTitle = "Transcribe Microphone";
        AppState.NotifyStateChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _transcriber = new RealtimeTranscriber();
            if (IsClientSide())
            {
                _transcriber.Token = await GetTokenAsync();
            }
            else
            {
                _transcriber.ApiKey = Configuration["AssemblyAI:ApiKey"];
            }
            _transcriber.PartialTranscriptReceived += OnPartialTranscriptReceived;
            _transcriber.FinalTranscriptReceived += OnFinalTranscriptReceived;
            _transcriber.ErrorReceived += OnErrorReceived;
            _transcriber.Closed += OnClosed;
            _transcriber.ObservableForProperty(t => t.Status)
                .Subscribe(status => { Status = status.Value; });

            _jsMicrophone = await JsMicrophone.CreateAsync(JsRuntime, "/audio.mjs");
            _jsMicrophone.OnAudioData += JsMicrophoneOnOnAudioData;
        }
    }

    private void JsMicrophoneOnOnAudioData(byte[] audio)
    {
        _transcriber.SendAudio(audio);
    }

    private async Task<string> GetTokenAsync()
    {
        var tokenResponse = await HttpClient.PostAsync(
            NavigationManager.BaseUri + "api/realtime/token",
            null
        );
        tokenResponse.EnsureSuccessStatusCode();
        var tokenResponseObject = await tokenResponse.Content.ReadFromJsonAsync<RealtimeTemporaryTokenResponse>();
        return tokenResponseObject!.Token;
    }

    private async Task TranscribeToggleClick()
    {
        switch (Status)
        {
            case RealtimeTranscriberStatus.Disconnected:
                await _transcriber.ConnectAsync().ConfigureAwait(false);
                await _jsMicrophone.StartRecordingAsync().ConfigureAwait(false);
                break;
            case RealtimeTranscriberStatus.Connected:
                _jsMicrophone.StopRecordingAsync();
                await _transcriber.CloseAsync().ConfigureAwait(false);
                break;
            default:
                throw new UnreachableException();
        }
    }

    private void OnErrorReceived(RealtimeTranscriber sender, global::AssemblyAI.Realtime.ErrorEventArgs evt)
    {
        Error = evt.Error;
    }

    private void OnClosed(RealtimeTranscriber sender, ClosedEventArgs evt)
    {
        if (evt.Code == (int)WebSocketCloseStatus.NormalClosure) return;
        Error = $"Socket closed with code {evt.Code}: {evt.Reason}";
    }

    private void OnPartialTranscriptReceived(RealtimeTranscriber sender, PartialTranscriptEventArgs evt)
    {
        if (evt.Result.Text == "") return;
        foreach (var word in evt.Result.Words)
        {
            _transcriptWords[word.Start] = word.Text;
        }

        BuildTranscript();
    }

    private void OnFinalTranscriptReceived(RealtimeTranscriber sender, FinalTranscriptEventArgs evt)
    {
        foreach (var word in evt.Result.Words)
        {
            _transcriptWords[word.Start] = word.Text;
        }

        BuildTranscript();
    }

    private void BuildTranscript()
    {
        var stringBuilder = new StringBuilder();
        foreach (var word in _transcriptWords.Values)
        {
            stringBuilder.Append($"{word} ");
        }

        Transcript = stringBuilder.ToString();
        InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        if (_transcriber is not null)
        {
            await _transcriber.DisposeAsync().ConfigureAwait(false);
        }

        if (_jsMicrophone is not null)
        {
            await _jsMicrophone.DisposeAsync().ConfigureAwait(false);
        }
    }

    private bool IsClientSide() => JsRuntime is IJSInProcessRuntime;
}